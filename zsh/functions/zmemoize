#!/bin/zsh

##
## Standard memoization preserves standard output (if less than XX bytes), and the
## return value.
##
## In addition to the arguments, the following components may be added to the
## memoization key:
##
##    -o <optionlist>
##        ZSH option settings; option names are expressed as space or comma separated
##        names in string form, e.g. "login,promptpercent"
##

typeset -g -H -A zmemoize_config
typeset -g -H -A zmemoize_defs
typeset -g -H -A zmemoize_cache

function _zmemoize_calculate_key {
  emulate -L zsh
  local funcname=$1 key="" funcall=""
  typeset -A memodef addons
  shift
  
  [[ -n "$zmemoize_defs[$funcname]" ]] && zavp -d -v memodef $zmemoize_defs[$funcname]
  
  key="${funcname}:${(pj:\0:)*}"
  
  [[ $memodef[vary_pwd] == 1 ]] && addons[pwd]=$PWD
  [[ $memodef[vary_username] == 1 ]] && addons[username]=$USERNAME
  [[ $memodef[vary_hostname] == 1 ]] && addons[hostname]=$HOST
  [[ $memodef[vary_pid] == 1 ]] && addons[pid]=$$
  [[ $memodef[vary_session] == 1 ]] && addons[session]=$(dotto_session_id)
  [[ $memodef[vary_tty] == 1 ]] && addons[tty]=$TTY
  [[ $memodef[vary_euid] == 1 ]] && addons[euid]="${EUID}"
  [[ $memodef[vary_egid] == 1 ]] && addons[egid]="${EGID}"

  addons[options]=
  if [[ -n $memodef[vary_options] ]]; then
    local option=
    for option in "${(ops:,:)memodef[vary_options]}"; do
      zctrace "Checking options: $option..."
      addons[options]+=":${option//_/}=$options[$option]:"
    done
  fi
  
  addons[files]=
  if [[ -n $memodef[vary_file] ]]; then
    local vfile= fsize= mtime=
    for vfile in "${(ops.:.)memodef[vary_file]}"; do
      # no file, mark as such
      [[ ! -f $vfile ]] && { addons[files]+="(^$vfile)"; continue }
      mtime=$(builtin stat +mtime $vfile)
      fsize=$(builtin stat +size $vfile)
      addons[files]+="($file,$mtime,$fsize)"
    done
  fi 2>/dev/null

  [[ -n $memodef[vary_function] ]] && funcall=$memodef[vary_function] && \
      addons[funcall]=$(${(z)funcall} 2>/dev/null)
  [[ -n $memodef[vary_eval] ]] && addons[evalcall]=${(e)~memodef[vary_eval]} 2>/dev/null

  if [[ ${#addons} -gt 0 ]]; then
    key+=":${(pj:\0:)${(@kv)addons}}"
  fi
  
  echo -n -E $key
}

function _zmemoize_capture {
  local key=$1 funcname=$2
  shift 2
  
  # zlog "capturing $key..."
  local coutput cstatus
  local wrapper="_zmemoize_wrapped_$funcname"
  typeset -A memoavps memodef

  [[ -n "$zmemoize_defs[$funcname]" ]] && zavp -d -v memodef $zmemoize_defs[$funcname]

  case $(zshellfunc_type $wrapper) in
    alias) 
         # get actual effective command
         wrapper=${$(builtin alias $wrapper)#${wrapper}=}
         # dequote if necessary
         wrapper=${${wrapper#[\'\"]}%[\'\"]}
      ;;
  esac

  local stdout= newline= stderr= tmpfile=
  newline=$(print -l "" "tail")
  newline="${newline%tail}"

  # stderr capturing version
  if [[ $memodef[stderr] == 1 ]]; then
    tmpfile=${TMPPREFIX:-"/tmp/zsh"}.zmemoize.$$.$SECONDS
    stdout=$(${(z)wrapper} "${(@)*}" 2>! $tmpfile)
    
    if [[ -s $tmpfile ]]; then
      memoavps[has_stderr]=1
      memoavps[stderr]=$(< $tmpfile)
      memoavps[stderr]+=$newline
    fi
  else
    stdout=$(${(z)wrapper} "${(@)*}")
  fi

  stdout+="${newline}"  
  memoavps[stdout]=$stdout
  memoavps[status]=$?

  [[ -n $memodef[timeout] ]] && memoavps[expires]=$(($EPOCHSECONDS + $memodef[timeout]))

  zmemoize_cache[$key]=$(zavp -v memoavps)
  
  # zlog "MEMOAVP keys are ${(k)memoavps}, stdout is $memoavps[stdout], str is $(echo $zmemoize_cache[$key] | cat -vt)"

  echo -n -E "$memoavps[stdout]"
  [[ $memoavps[has_stderr] == 1 ]] && echo -n -E $memoavps[stderr] >&2
  return $memoavps[status]
}

#
# Clear the cache and unmemoize all memoized functions
#
function zmemoize_reset {
  typeset -g -H -A zmemoize_cache
  for key in "${(@k)zmemoize_cache}"; do
    unset "zmemoize_cache[$key]"
  done

  typeset -g -H -A zmemoize_config
  typeset -g -H -A zmemoize_defs
  
  local funcname
  for funcname in "${(@k)zmemoize_defs}"; do
    zmemoize -u $funcname
  done
}

#
# Clear all or part of the cache
#
function zmemoize_clear {
  emulate -L zsh
  local pattern=$1 key
  
  if [[ -n $pattern ]]; then
    local isdone=0
    while [[ $isdone == 0 ]]; do
      key=${zmemoize_cache[(i)$pattern]}
      if [[ -n $key ]]; then
        unset "zmemoize_cache[$key]"
      else
        isdone=1
      fi
    done
  else
    unset zmemoize_cache
    typeset -g -H -A zmemoize_cache
  fi
}


function _zmemoize_wrapper {
  local key="" cached="" funcname=$1 capture=1

  key=$(_zmemoize_calculate_key $*)
  cached=$zmemoize_cache[$key]

  # zctrace "wrapper: func is $1, key is $key" >&2
  # zctrace "cached is ..$cached..${#cached}"
  
  ## short result means a status code; unset and return
  if [[ -n $cached ]]; then
    typeset -A zdecoded
    if zavp -d -v zdecoded $cached 2>/dev/null; then
      if [[ -n $zdecoded[expires] && $zdecoded[expires] -le $EPOCHSECONDS ]]; then
        zlog "zmemoize_wrapper: expiring $funcname:$* entry"
        capture=1
        unset "zmemoize_cache[$key]"
      else
        echo -n -E "$zdecoded[stdout]"
        if [[ -n $zdecoded[has_stderr] ]]; then
          echo -n -E "$zdecoded[stderr]" >&2
        fi
        return $zdecoded[status]
      fi
    fi
  fi

  if [[ $capture == 1 ]]; then
    _zmemoize_capture $key $*
  else
    $*
  fi
}

function zmemoize {
  emulate -L zsh

  local opt usage OPTIND OPTARG delete=0 verbose=0 clear=1 action=memoize require_funcname=1
  local funcname wrappername

  typeset -A memodef

  # defaults
  memodef[timeout]=1800
  memodef[stderr]=0
  memodef[vary_pwd]=0
  memodef[vary_hostname]=1
  memodef[vary_username]=1

  usage="Usage: zmemoize <options> FUNCTIONNAME
  
    Many of the options below inject additional data into the memoization key,
    and are additive. This can be used to make manifest the implicit arguments
    like environment that may be important to correct memoization of a non-pure
    function.
    
Options:
    -h   Show this help.
    -l   Print a list of memoized functions.
    -c   Clear memoization cache.  If a function name is supplied, clear the
         entries only for that funciton.
    -m   Memoize the named function (default action)
    -r   Reset entire memoization system, clearing cache and unmemoizing 
         all functions.
    -u   Unmemoize named function
    -t <seconds> 
         Memoization timeout -- note that the memoized value is not guaranteed
         to persist for this period, or indeed for any period as the cache may
         be flushed.  Default is 30 minutes (1800 seconds)
    -e   Also memoize and replay standard error output.
    -p   Print the parameters of a function
    -P   Inject current working directory (\$PWD)
    -O <optionlist>
         Inject the setting status of ZSH options given in a comma separated list
         of option names (e.g. automenu,warn_create_global,promptsubst).
    -F <functionname>
         Inject the output of a named function evaluated each time the memoized
         function is called.
    -V <varstring>
         Inject the output of expanding a string at call time.  The argument
         should be a variable reference, parameter expansion, process substitution,
         or arithmetic expansion, or some combination of those.  Examples:
            -V '$foo'        -> the run-time value of the variable 'foo'
            -V '$(ls -l)'    -> The output of running ls -l
            -V '${(k)assoc}' -> the keys of the array names 'assoc'
            -V '*'           -> all files in the current directory
    -I   Inject process ID (\$\$)
    -S   Inject the dotto_session_id
    -T   Inject the TTY name
    -D <FILENAMES>
         Inject a dependency on the timestamp and size of one or more files
         which are contained in a path-like, colon separated string FILENAMEs.
         e.g. (-D /tmp/file1:/etc/passwd)
    -G   Inject the EGID (effective GID)
    -E   Inject the EUID (effective UID)
    -H   Hostname.  Set by default. May be disabled with '+h'.
    -U   Username.  Set by default. May be disabled with '+u'.
"

  while getopts "cehlmprt:uvD:EF:GHIO:PSTUV:" opt; do
    case "$opt" in
      h) echo -E $usage; return 0 ;;
      m) action=memoize; require_funcname=1;;
      u) delete=1; action=unmemoize ;;
      c) action=clear; require_funcname=0 ;;
      p) action=print; require_funcname=1 ;;
      r) action=reset; require_funcname=0;;
      l) action=list
         print ${(k)zmemoize_defs}
         return
         ;;
      e) memodef[stderr]=1 ;;
      t) memodef[timeout]=$OPTARG ;;
      U) memodef[vary_username]=1 ;;
      H) memodef[vary_hostname]=1 ;;
      +U) memodef[vary_username]=0 ;;
      +H) memodef[vary_hostname]=0 ;;
      P) memodef[vary_pwd]=1 ;;
      I) memodef[vary_pid]=1 ;;
      S) memodef[vary_session]=1 ;;
      T) memodef[vary_tty]=1 ;;
      G) memodef[vary_egid]=1 ;;
      E) memodef[vary_euid]=1 ;;
      F) memodef[vary_function]=$OPTARG ;;
      V) memodef[vary_eval]=$OPTARG ;;
      O) memodef[vary_options]=$OPTARG ;;
      D) 
          local dfile= 
          typeset -a dfiles
          for dfile in "${(ops.:.)OPTARG}"; do
            dfiles+=$(zrealpath $dfile)
          done
          memodef[vary_file]="${(j.:.)dfiles}"
          ;;
      v) verbose=1 ;;
      *) echo -E $usage; return 1;;
    esac
  done

  shift $(( OPTIND - 1 ))

  if [[ $require_funcname == 1 ]] && (( $# != 1 )); then
    echo -E $usage
    return 1
  fi

  funcname=$1
  wrappername="_zmemoize_wrapped_$funcname"

  case $action in
    clear)
        zmemoize_clear $funcname
        return
      ;;
    reset) 
        zmemoize_reset
        return
      ;;
    print)
        local key=""
        typeset -A printdef
        [[ -z $zmemoize_defs[$funcname] ]] && { echo "Function $funcname not memoized." >&2; return 1 }
        
        zavp -d -v printdef $zmemoize_defs[$funcname]
        for key in ${(ko)printdef}; do
          echo -E "$key: ${printdef[$key]}"
        done
        return
      ;;
    memoize) ;;
    unmemoize) ;;
    *) echo "Unknown action: $action" >&2; exit 1;;
  esac

  # clear all cached bits
  [[ -n $funcname ]] || { echo "Must provide a function name"; return 1 }
  
  zmemoize_clear "${funcname}:*"

  # if deletion is requested, or function is already memoized
  if [[ $action == "unmemoize" || $delete == 1 || -n $zmemoize_defs[$funcname] ]]; then
    if [[ -n $zmemoize_defs[$funcname] ]]; then
      zctrace "unmemoizing $funcname from $wrappername"

      unset "zmemoize_defs[$funcname]"      
      unfunction $funcname

      zshellfunc_rename $wrappername $funcname || { echo "FAILED TO RENAME BACK: $?" >&2; return 21 }
    else
      [[ $action == "unmemoize" ]] && return 35
    fi
  fi
  
  if [[ $action == "memoize" ]]; then
    zctrace "memoizing $funcname to $wrappername"
  
    unfunction $wrappername &>/dev/null
    zshellfunc_rename $funcname $wrappername || { echo "FAILED TO RENAME: $?" >&2; return 20 }
    function $funcname {
      _zmemoize_wrapper $0 $*
    }
    
    zmemoize_defs[$funcname]=$(zavp -v memodef)
  fi
}

zmemoize_reset
