#!/bin/zsh

##
## Standard memoization preserves standard output (if less than XX bytes), and the
## return value.
##
## NOTE that none of the options are implemented yet.  Only the plain name form
## works!
##
## Syntax:
##
##    zmemoize [<options>] functionname
##
## General options
##
##    -t <seconds> 
##         Memoization timeout -- note that the memoized value is not guaranteed
##         to persist for this period, or indeed for any period as the cache may
##         be flushed
##
##    -E
##         Also memoize standard error output.
##
## In addition to the arguments, the following components may be added to the
## memoization key:
##
##    -P   
##         Current working directory ($PWD)
##
##    -f <function>
##         a function name to be evaluated at call time
##
##    -v <varstring>
##         a variable reference to be evaluated at call time - full expansion is performed
##
##    -g <glob>
##         a glob to be evaluated at call time
##
##    -o <optionlist>
##        ZSH option settings; option names are expressed as space or comma separated
##        names in string form, e.g. "login,promptpercent"
##
##    -H
##        Hostname.  Set by default. May be disabled with "+h".
##
##    -u
##        Username.  Set by default. May be disabled with "+u".
##

typeset -g -H -A zmemoize_config
typeset -g -H -A zmemoize_defs
typeset -g -H -A zmemoize_cache

function _zmemoize_calculate_key {
  emulate -L zsh
  local funcname=$1 key=""
  typeset -A memodef
  shift
  
  [[ -n "$zmemoize_defs[$funcname]" ]] && zavp -d -v memodef $zmemoize_defs[$funcname]
  
  key="${funcname}:${(pj:\0:)*}"
  
  echo -E $key
}

function _zmemoize_capture {
  local key=$1 funcname=$2
  shift 2
  
  # zlog "capturing $key..."
  local coutput cstatus
  local wrapper="_zmemoize_wrapped_$funcname"
  typeset -A memoavps memodef

  [[ -n "$zmemoize_defs[$funcname]" ]] && zavp -d -v memodef $zmemoize_defs[$funcname]

  case $(zshellfunc_type $wrapper) in
    alias) 
         # get actual effective command
         wrapper=${$(builtin alias $wrapper)#${wrapper}=}
         # dequote if necessary
         wrapper=${${wrapper#[\'\"]}%[\'\"]}
      ;;
  esac

  memoavps[stdout]=$(${(z)wrapper} "${(@)*}")
  memoavps[status]=$?
  [[ -n $memodef[timeout] ]] && memoavps[expires]=$(($EPOCHSECONDS + $memodef[timeout]))

  zmemoize_cache[$key]=$(zavp -v memoavps)
  
  # zlog "MEMOAVP keys are ${(k)memoavps}, stdout is $memoavps[stdout], str is $(echo $zmemoize_cache[$key] | cat -vt)"

  echo -E "$memoavps[stdout]"
  return $memoavps[status]
}

#
# Clear the cache and unmemoize all memoized functions
#
function zmemoize_reset {
  zmemoize_cache=

  typeset -g -H -A zmemoize_config
  typeset -g -H -A zmemoize_defs
  typeset -g -H -A zmemoize_cache
  
  local funcname
  for funcname in "${(@k)zmemoize_defs}"; do
    zmemoize -U $funcname
  done
}

#
# Clear all or part of the cache
#
function zmemoize_clear {
  emulate -L zsh
  local pattern=$1
  
  if [[ -n $pattern ]]; then
    local isdone=0
    while [[ $isdone == 0 ]]; do
      key=${zmemoize_cache[(i)$pattern]}
      if [[ -n $key ]]; then
        unset "zmemoize_cache[$key]"
      else
        isdone=1
      fi
    done
  else
    unset zmemoize_cache
    typeset -g -H -A zmemoize_cache
  fi
}


function _zmemoize_wrapper {
  local key="" cached="" funcname=$1 capture=1

  key=$(_zmemoize_calculate_key $*)
  cached=$zmemoize_cache[$key]

  # zctrace "wrapper: func is $1, key is $key" >&2
  # zctrace "cached is ..$cached..${#cached}"
  
  ## short result means a status code; unset and return
  if [[ -n $cached ]]; then
    typeset -A zdecoded
    if zavp -d -v zdecoded $cached 2>/dev/null; then
      if [[ -n $zdecoded[expires] && $zdecoded[expires] -le $EPOCHSECONDS ]]; then
        zlog "zmemoize_wrapper: expiring $funcname:$* entry"
        capture=1
        unset "zmemoize_cache[$key]"
      else
        echo -E "$zdecoded[stdout]"
        return $zdecoded[status]
      fi
    fi
  fi

  if [[ $capture == 1 ]]; then
    _zmemoize_capture $key $*
  else
    $*
  fi
}

function zmemoize {
  emulate -L zsh

  local opt usage OPTIND OPTARG delete=0 verbose=0 clear=1 action=memoize require_funcname=1
  local funcname wrappername

  typeset -A memodef

  # defaults
  memodef[timeout]=90
  memodef[stderr]=0
  memodef[vary_pwd]=0
  memodef[vary_hostname]=0
  memodef[vary_username]=0

  usage='Usage: zmemoize <options> functionname
Options:
    -t <seconds> 
         Memoization timeout -- note that the memoized value is not guaranteed
         to persist for this period, or indeed for any period as the cache may
         be flushed

    -c   Clear cache.
    
    -r   Reset entire memoization system, clearing cache and unmemoizing 
         all functions.

    -E
         Also memoize standard error output.
         
    -U   Unmemoize function

    -P   
         Current working directory ($PWD)
    -H
        Hostname.  Set by default. May be disabled with "+h".

    -u
        Username.  Set by default. May be disabled with "+u".
    
    -h  This help.
    
    -l  Print a list of memoized functions.
'

  while getopts "crUEphPt:l" opt; do
    case "$opt" in
      U) delete=1; action=unmemoize ;;
      c) action=clear; require_funcname=0 ;;
      E) memodef[stderr]=1 ;;
      t) memodef[timeout]=$OPTARG ;;
      p) memodef[vary_hostname]=1 ;;
      H) memodef[vary_hostname]=1 ;;
      P) memodef[vary_pwd]=1 ;;
      v) verbose=1 ;;
      r) action=reset; require_funcname=0;;
      l) action=list
         print ${(k)zmemoize_defs}
         return
         ;;
      h) print $usage; return 0 ;;
      *) print $usage; return 1;;
    esac
  done

  shift $(( OPTIND - 1 ))

  if [[ $require_funcname == 1 ]] && (( $# != 1 )); then
    print $usage
    return 1
  fi

  funcname=$1
  wrappername="_zmemoize_wrapped_$funcname"

  case $action in
    clear)
        zmemoize_clear $funcname
        return
      ;;
    reset) 
        zmemoize_reset
        return
      ;;
    memoize) ;;
    unmemoize) ;;
    *) echo "Unknown action: $action" >&2; exit 1;;
  esac

  # clear all cached bits
  [[ -n $funcname ]] || { echo "Must provide a function name"; return 1 }
  
  zmemoize_clear "${funcname}:*"

  # if deletion is requested, or function is already memoized
  if [[ $delete == 1 || -n $zmemoize_defs[$funcname] ]]; then
    if [[ -n $zmemoize_defs[$funcname] ]]; then
      zctrace "unmemoizing $funcname from $wrappername"

      unset "zmemoize_defs[$funcname]"      
      unfunction $funcname

      zshellfunc_rename $wrappername $funcname || { echo "FAILED TO RENAME BACK: $?" >&2; return 21 }
      return 0
    else
      [[ $action == "unmemoize" ]] && return 35
    fi
  fi
  
  if [[ $action == "memoize" ]]; then
    zctrace "memoizing $funcname to $wrappername"
  
    unfunction $wrappername &>/dev/null
    zshellfunc_rename $funcname $wrappername || { echo "FAILED TO RENAME: $?" >&2; return 20 }
    function $funcname {
      _zmemoize_wrapper $0 $*
    }
    
    zmemoize_defs[$funcname]=$(zavp -v memodef)
  fi
}

zmemoize_reset
