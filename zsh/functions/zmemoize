#!/bin/zsh

##
## Standard memoization preserves standard output (if less than XX bytes), and the
## return value.
##
## NOTE that none of the options showh here are implemented yet.  See the usage text
## from "zmemoize -h" to see what works!
##
## Syntax:
##
##    zmemoize [<options>] functionname
##
## General options
##
##    -E
##         Also memoize standard error output.
##
## In addition to the arguments, the following components may be added to the
## memoization key:
##
##    -P   Current working directory ($PWD)
##
##    -g <glob>
##         a glob to be evaluated at call time
##
##    -o <optionlist>
##        ZSH option settings; option names are expressed as space or comma separated
##        names in string form, e.g. "login,promptpercent"
##

typeset -g -H -A zmemoize_config
typeset -g -H -A zmemoize_defs
typeset -g -H -A zmemoize_cache

function _zmemoize_calculate_key {
  emulate -L zsh
  local funcname=$1 key="" funcall=""
  typeset -A memodef addons
  shift
  
  [[ -n "$zmemoize_defs[$funcname]" ]] && zavp -d -v memodef $zmemoize_defs[$funcname]
  
  key="${funcname}:${(pj:\0:)*}"
  
  [[ $memodef[vary_pwd] == 1 ]] && addons[pwd]=$PWD
  [[ $memodef[vary_username] == 1 ]] && addons[username]=$USERNAME
  [[ $memodef[vary_hostname] == 1 ]] && addons[hostname]=$HOSTNAME
  [[ -n $memodef[vary_function] ]] && funcall=$memodef[vary_function] && \
      addons[funcall]=$(${(z)funcall} 2>/dev/null)
  [[ -n $memodef[vary_eval] ]] && addons[evalcall]=$(eval "echo $memodef[vary_eval]" 2>/dev/null)

  if [[ ${#addons} -gt 0 ]]; then
    key+=":${(pj:\0:)${(kv)addons}}"
  fi
  
  echo -E $key
}

function _zmemoize_capture {
  local key=$1 funcname=$2
  shift 2
  
  # zlog "capturing $key..."
  local coutput cstatus
  local wrapper="_zmemoize_wrapped_$funcname"
  typeset -A memoavps memodef

  [[ -n "$zmemoize_defs[$funcname]" ]] && zavp -d -v memodef $zmemoize_defs[$funcname]

  case $(zshellfunc_type $wrapper) in
    alias) 
         # get actual effective command
         wrapper=${$(builtin alias $wrapper)#${wrapper}=}
         # dequote if necessary
         wrapper=${${wrapper#[\'\"]}%[\'\"]}
      ;;
  esac

  local stdout= newline= stderr= tmpfile=
  newline=$(print -l "" "tail")
  newline="${newline%tail}"

  # stderr capturing version
  if [[ $memodef[stderr] == 1 ]]; then
    tmpfile=${TMPPREFIX:-"/tmp/zsh"}.zmemoize.$$.$SECONDS
    stdout=$(${(z)wrapper} "${(@)*}" 2>! $tmpfile)
    
    if [[ -s $tmpfile ]]; then
      memoavps[has_stderr]=1
      memoavps[stderr]=$(< $tmpfile)
      memoavps[stderr]+=$newline
    fi
  else
    stdout=$(${(z)wrapper} "${(@)*}")
  fi

  stdout+="${newline}"  
  memoavps[stdout]=$stdout
  memoavps[status]=$?

  [[ -n $memodef[timeout] ]] && memoavps[expires]=$(($EPOCHSECONDS + $memodef[timeout]))

  zmemoize_cache[$key]=$(zavp -v memoavps)
  
  # zlog "MEMOAVP keys are ${(k)memoavps}, stdout is $memoavps[stdout], str is $(echo $zmemoize_cache[$key] | cat -vt)"

  echo -n -E "$memoavps[stdout]"
  [[ $memoavps[has_stderr] == 1 ]] && echo -n -E $memoavps[stderr] >&2
  return $memoavps[status]
}

#
# Clear the cache and unmemoize all memoized functions
#
function zmemoize_reset {
  typeset -g -H -A zmemoize_cache
  for key in "${(@k)zmemoize_cache}"; do
    unset "zmemoize_cache[$key]"
  done

  typeset -g -H -A zmemoize_config
  typeset -g -H -A zmemoize_defs
  
  local funcname
  for funcname in "${(@k)zmemoize_defs}"; do
    zmemoize -U $funcname
  done
}

#
# Clear all or part of the cache
#
function zmemoize_clear {
  emulate -L zsh
  local pattern=$1 key
  
  if [[ -n $pattern ]]; then
    local isdone=0
    while [[ $isdone == 0 ]]; do
      key=${zmemoize_cache[(i)$pattern]}
      if [[ -n $key ]]; then
        unset "zmemoize_cache[$key]"
      else
        isdone=1
      fi
    done
  else
    unset zmemoize_cache
    typeset -g -H -A zmemoize_cache
  fi
}


function _zmemoize_wrapper {
  local key="" cached="" funcname=$1 capture=1

  key=$(_zmemoize_calculate_key $*)
  cached=$zmemoize_cache[$key]

  # zctrace "wrapper: func is $1, key is $key" >&2
  # zctrace "cached is ..$cached..${#cached}"
  
  ## short result means a status code; unset and return
  if [[ -n $cached ]]; then
    typeset -A zdecoded
    if zavp -d -v zdecoded $cached 2>/dev/null; then
      if [[ -n $zdecoded[expires] && $zdecoded[expires] -le $EPOCHSECONDS ]]; then
        zlog "zmemoize_wrapper: expiring $funcname:$* entry"
        capture=1
        unset "zmemoize_cache[$key]"
      else
        echo -n -E "$zdecoded[stdout]"
        if [[ -n $zdecoded[has_stderr] ]]; then
          echo -n -E "$zdecoded[stderr]" >&2
        fi
        return $zdecoded[status]
      fi
    fi
  fi

  if [[ $capture == 1 ]]; then
    _zmemoize_capture $key $*
  else
    $*
  fi
}

function zmemoize {
  emulate -L zsh

  local opt usage OPTIND OPTARG delete=0 verbose=0 clear=1 action=memoize require_funcname=1
  local funcname wrappername

  typeset -A memodef

  # defaults
  memodef[timeout]=90
  memodef[stderr]=0
  memodef[vary_pwd]=0
  memodef[vary_hostname]=1
  memodef[vary_username]=1

  usage='Usage: zmemoize <options> functionname
Options:
    -t <seconds> 
         Memoization timeout -- note that the memoized value is not guaranteed
         to persist for this period, or indeed for any period as the cache may
         be flushed
    -c   Clear cache.
    -r   Reset entire memoization system, clearing cache and unmemoizing 
         all functions.
    -E   Also memoize standard error output.
    -U   Unmemoize function
    -P   Current working directory ($PWD)
    -f <function>
         a function name to be evaluated at call time
    -v <varstring>
         a variable reference to be evaluated at call time - full expansion is performed
    -H   Hostname.  Set by default. May be disabled with "+h".
    -u   Username.  Set by default. May be disabled with "+u".
    -l   Print a list of memoized functions.
    -h   This help.
'

  while getopts "VcrUEphPt:lf:v:" opt; do
    case "$opt" in
      U) delete=1; action=unmemoize ;;
      c) action=clear; require_funcname=0 ;;
      E) memodef[stderr]=1 ;;
      t) memodef[timeout]=$OPTARG ;;
      u) memodef[vary_username]=1 ;;
      H) memodef[vary_hostname]=1 ;;
      +u) memodef[vary_username]=0 ;;
      +H) memodef[vary_hostname]=0 ;;
      p) action=print; require_funcname=1 ;;
      P) memodef[vary_pwd]=1 ;;
      f) memodef[vary_function]=$OPTARG ;;
      v) memodef[vary_eval]=$OPTARG ;;
      V) verbose=1 ;;
      r) action=reset; require_funcname=0;;
      l) action=list
         print ${(k)zmemoize_defs}
         return
         ;;
      h) print $usage; return 0 ;;
      *) print $usage; return 1;;
    esac
  done

  shift $(( OPTIND - 1 ))

  if [[ $require_funcname == 1 ]] && (( $# != 1 )); then
    print $usage
    return 1
  fi

  funcname=$1
  wrappername="_zmemoize_wrapped_$funcname"

  case $action in
    clear)
        zmemoize_clear $funcname
        return
      ;;
    reset) 
        zmemoize_reset
        return
      ;;
    memoize) ;;
    unmemoize) ;;
    *) echo "Unknown action: $action" >&2; exit 1;;
  esac

  # clear all cached bits
  [[ -n $funcname ]] || { echo "Must provide a function name"; return 1 }
  
  zmemoize_clear "${funcname}:*"

  # if deletion is requested, or function is already memoized
  if [[ $delete == 1 || -n $zmemoize_defs[$funcname] ]]; then
    if [[ -n $zmemoize_defs[$funcname] ]]; then
      zctrace "unmemoizing $funcname from $wrappername"

      unset "zmemoize_defs[$funcname]"      
      unfunction $funcname

      zshellfunc_rename $wrappername $funcname || { echo "FAILED TO RENAME BACK: $?" >&2; return 21 }
    else
      [[ $action == "unmemoize" ]] && return 35
    fi
  fi
  
  if [[ $action == "memoize" ]]; then
    zctrace "memoizing $funcname to $wrappername"
  
    unfunction $wrappername &>/dev/null
    zshellfunc_rename $funcname $wrappername || { echo "FAILED TO RENAME: $?" >&2; return 20 }
    function $funcname {
      _zmemoize_wrapper $0 $*
    }
    
    zmemoize_defs[$funcname]=$(zavp -v memodef)
  fi
}

zmemoize_reset
