#!/bin/zsh

##
## Standard memoization preserves standard output (if less than XX bytes), and the
## return value.
##
## NOTE that none of the options are implemented yet.  Only the plain name form
## works!
##
## Syntax:
##
##    zmemoize [<options>] functionname
##
## General options
##
##    -t <seconds> 
##         Memoization timeout -- note that the memoized value is not guaranteed
##         to persist for this period, or indeed for any period as the cache may
##         be flushed
##
##    -E
##         Also memoize standard error output.
##
## In addition to the arguments, the following components may be added to the
## memoization key:
##
##    -P   
##         Current working directory ($PWD)
##
##    -f <function>
##         a function name to be evaluated at call time
##
##    -v <varstring>
##         a variable reference to be evaluated at call time - full expansion is performed
##
##    -g <glob>
##         a glob to be evaluated at call time
##
##    -o <optionlist>
##        ZSH option settings; option names are expressed as space or comma separated
##        names in string form, e.g. "login,promptpercent"
##
##    -h
##        Hostname.  Set by default. May be disabled with "+h".
##
##    -u
##        Username.  Set by default. May be disabled with "+u".
##


function _zmemoize_calculate_key {
  emulate -L zsh
  echo ${(pj:\0:)*}
}

function _zmemoize_capture {
  local key=$1 funcname=$2
  shift 2
  
  zctrace "capturing $key..."
  local coutput cstatus
  coutput=$(_zmemoize_wrapped_$funcname $*)
  cstatus=$?
  cstderr=""

  zmemoize_cache[$key]=$(zavp stdout $coutput status $cstatus stderr $cstderr)

  echo "$coutput"
  return $cstatus
}

function _zmemoize_replay {
  emulate -L zsh
  local funcname=$1 key=$2 cached=$3

  local -A decoded
  if zavp -d -v decoded $cached; then
    zctrace "decoded keys are ${(k)decoded}"
    echo $decoded[stdout]
    return $decoded[status]
  fi

  echo "REPLAY: $cached" && return 254
}

function zmemoize_reset {
  unset zmemoize_config zmemoize_defs zmemoize_cache

  typeset -g -H -A zmemoize_config
  typeset -g -H -A zmemoize_defs
  typeset -g -H -A zmemoize_cache
}

function zmemoize_clear {
  unset zmemoize_cache
  typeset -g -H -A zmemoize_cache
}


function _zmemoize_wrapper {
  local key cached funcname
  funcname=$1
  key=$(_zmemoize_calculate_key $*)
  zctrace "wrapper: func is $1, key is $key" >&2

  zctrace "cached is ..$cached..${#cached}"
  
  ## short result means a status code; unset and return
  if [[ -z $zmemoize_cache[$key] ]]; then
    _zmemoize_capture $key $*
    return
  fi

  _zmemoize_replay $funcname $key $zmemoize_cache[$key]
}

function zmemoize {
  emulate -L zsh

  local opt usage funcname

  usage='Usage: zmemoize <options> functionname
Options:
    -c              Show currently selected theme and parameters
    -l              List currently available prompt themes
    -p [<themes>]   Preview given themes (defaults to all)
    -h [<theme>]    Display help (for given theme)
    -s <theme>      Set and save theme
    <theme>         Switch to new theme immediately (changes not saved)
'

  while getopts "chlps:t:P:" opt; do
    case "$opt" in
      (h|p)
        setopt localtraps
        if [[ -z "$prompt_theme[1]" ]]; then
          # Not using a prompt theme; save settings
          local -a psv; psv=($psvar); local -a +h psvar; psvar=($psv) # Ick
  	local +h PS1=$PS1 PS2=$PS2 PS3=$PS3 PS4=$PS4 RPS1=$RPS1
  	local precmd_functions preexec_functions
        else
          trap 'prompt_${prompt_theme[1]}_setup "${(@)prompt_theme[2,-1]}"' 0
        fi
        ;;
    esac
    case "$opt" in
      c) if [[ -n $prompt_theme ]]; then
           print -n "Current prompt theme"
           (( $#prompt_theme > 1 )) && print -n " with parameters"
           print " is:\n  $prompt_theme"
         else
           print "Current prompt is not a theme."
         fi
         return
         ;;
      h) if [[ -n "$2" && -n $prompt_themes[(r)$2] ]]; then
           if functions prompt_$2_setup >/dev/null; then
  	   # The next line is a bit ugly.  It (perhaps unnecessarily)
  	   # runs the prompt theme setup function to ensure that if
  	   # the theme has a _help function that it's been autoloaded.
  	   prompt_$2_setup
  	 fi
           if functions prompt_$2_help >/dev/null; then
             print "Help for $2 theme:\n"
             prompt_$2_help
           else
             print "No help available for $2 theme."
           fi
           print "\nType \`prompt -p $2' to preview the theme, \`prompt $2'"
           print "to try it out, and \`prompt -s $2' to use it in future sessions."
         else
           print "$usage"
         fi
         ;;
      l) 
         print ${(i)zmemoize_defs}
         return
         ;;
      p) preview=( $prompt_themes )
         (( $#* > 1 )) && preview=( "$@[2,-1]" )
         for theme in $preview; do
           [[ "$theme" == "$prompt_theme[*]" ]] && continue
           prompt_preview_safely "$=theme"
         done
         print -P "%b%f%k"
         ;;
    esac
  done

  shift $(( OPTIND - 1 ))

  if (( $# != 1 )); then
    print $usage
    return 1
  fi

  funcname=$1
  wrappername="_zmemoize_wrapped_$funcname"
  zctrace "memoizing $funcname to $wrappername"
  
  unfunction $wrappername &>/dev/null
  zshellfunc_rename $funcname $wrappername || { echo "FAILED TO RENAME: $?"; return 20 }
  function $funcname {
    _zmemoize_wrapper $0 $*
  }
}

zmemoize_reset
